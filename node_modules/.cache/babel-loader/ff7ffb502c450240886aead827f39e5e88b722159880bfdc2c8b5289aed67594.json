{"ast":null,"code":"const DB_NAME='MiniMarketProDB';const DB_VERSION=1;export const STORES=['products','sales','users','markets','suppliers','customers','cashMovements','expenses','salesTarget','desiredProfit','ReportsDashboard'];const openDB=()=>{return new Promise((resolve,reject)=>{const request=indexedDB.open(DB_NAME,DB_VERSION);request.onupgradeneeded=event=>{const db=event.target.result;STORES.forEach(storeName=>{if(!db.objectStoreNames.contains(storeName)){if(storeName.startsWith('cashMovements_')||storeName.startsWith('cashRegisterState_')){db.createObjectStore(storeName,{keyPath:'id'});}else{db.createObjectStore(storeName,{keyPath:'id',autoIncrement:true});}}});};request.onsuccess=event=>{resolve(event.target.result);};request.onerror=event=>{reject('Error opening IndexedDB:',event.target.error);};});};const getObjectStore=async(storeName,mode)=>{const db=await openDB();const transaction=db.transaction(storeName,mode);return transaction.objectStore(storeName);};export const getAllData=async storeName=>{const store=await getObjectStore(storeName,'readonly');return new Promise((resolve,reject)=>{const request=store.getAll();request.onsuccess=()=>resolve(request.result);request.onerror=()=>reject(request.error);});};export const addData=async(storeName,data)=>{const store=await getObjectStore(storeName,'readwrite');return new Promise((resolve,reject)=>{const request=store.add(data);request.onsuccess=()=>resolve(request.result);request.onerror=()=>reject(request.error);});};export const putData=async(storeName,data)=>{const store=await getObjectStore(storeName,'readwrite');return new Promise((resolve,reject)=>{const request=store.put(data);request.onsuccess=()=>resolve(request.result);request.onerror=()=>reject(request.error);});};export const deleteData=async(storeName,id)=>{const store=await getObjectStore(storeName,'readwrite');return new Promise((resolve,reject)=>{const request=store.delete(id);request.onsuccess=()=>resolve(request.result);request.onerror=()=>reject(request.error);});};export const clearStore=async storeName=>{const store=await getObjectStore(storeName,'readwrite');return new Promise((resolve,reject)=>{const request=store.clear();request.onsuccess=()=>resolve(request.result);request.onerror=()=>reject(request.error);});};export const initializeDBFromLocalStorage=async()=>{const db=await openDB();const transaction=db.transaction(STORES,'readwrite');for(const storeName of STORES){const store=transaction.objectStore(storeName);const countRequest=store.count();await new Promise((resolve,reject)=>{countRequest.onsuccess=()=>{if(countRequest.result===0){const localStorageData=JSON.parse(localStorage.getItem(storeName))||[];localStorageData.forEach(item=>{store.add(item);});console.log(\"IndexedDB store '\".concat(storeName,\"' initialized from localStorage.\"));}resolve();};countRequest.onerror=()=>reject(countRequest.error);});}console.log('IndexedDB initialization complete.');};export const syncLocalStorageWithIndexedDB=async(storeName,data)=>{try{localStorage.setItem(storeName,JSON.stringify(data));console.log(\"LocalStorage for '\".concat(storeName,\"' synchronized.\"));}catch(error){console.error(\"Error syncing \".concat(storeName,\":\"),error);}};export const syncWithBackend=async()=>{console.log('Sincronizando con backend...');for(const storeName of STORES){const localData=await getAllData(storeName);if(localData.length>0){console.log(\"Enviando \".concat(storeName,\" a backend:\"),localData);// Aquí iría la lógica real para enviar datos al backend\n}}console.log('Sincronización con backend completada.');};","map":{"version":3,"names":["DB_NAME","DB_VERSION","STORES","openDB","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","db","target","result","forEach","storeName","objectStoreNames","contains","startsWith","createObjectStore","keyPath","autoIncrement","onsuccess","onerror","error","getObjectStore","mode","transaction","objectStore","getAllData","store","getAll","addData","data","add","putData","put","deleteData","id","delete","clearStore","clear","initializeDBFromLocalStorage","countRequest","count","localStorageData","JSON","parse","localStorage","getItem","item","console","log","concat","syncLocalStorageWithIndexedDB","setItem","stringify","syncWithBackend","localData","length"],"sources":["C:/Users/lucas/Downloads/Minimarket PRO/src/utils/indexedDb.js"],"sourcesContent":["const DB_NAME = 'MiniMarketProDB';\r\nconst DB_VERSION = 1;\r\nexport const STORES = ['products', 'sales', 'users', 'markets', 'suppliers', 'customers', 'cashMovements', 'expenses', 'salesTarget', 'desiredProfit','ReportsDashboard'];\r\n\r\nconst openDB = () => {\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n\r\n    request.onupgradeneeded = (event) => {\r\n      const db = event.target.result;\r\n      STORES.forEach(storeName => {\r\n        if (!db.objectStoreNames.contains(storeName)) {\r\n          if (storeName.startsWith('cashMovements_') || storeName.startsWith('cashRegisterState_')) {\r\n            db.createObjectStore(storeName, { keyPath: 'id' });\r\n          } else {\r\n            db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    request.onsuccess = (event) => {\r\n      resolve(event.target.result);\r\n    };\r\n\r\n    request.onerror = (event) => {\r\n      reject('Error opening IndexedDB:', event.target.error);\r\n    };\r\n  });\r\n};\r\n\r\nconst getObjectStore = async (storeName, mode) => {\r\n  const db = await openDB();\r\n  const transaction = db.transaction(storeName, mode);\r\n  return transaction.objectStore(storeName);\r\n};\r\n\r\nexport const getAllData = async (storeName) => {\r\n  const store = await getObjectStore(storeName, 'readonly');\r\n  return new Promise((resolve, reject) => {\r\n    const request = store.getAll();\r\n    request.onsuccess = () => resolve(request.result);\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n};\r\n\r\nexport const addData = async (storeName, data) => {\r\n  const store = await getObjectStore(storeName, 'readwrite');\r\n  return new Promise((resolve, reject) => {\r\n    const request = store.add(data);\r\n    request.onsuccess = () => resolve(request.result);\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n};\r\n\r\nexport const putData = async (storeName, data) => {\r\n  const store = await getObjectStore(storeName, 'readwrite');\r\n  return new Promise((resolve, reject) => {\r\n    const request = store.put(data);\r\n    request.onsuccess = () => resolve(request.result);\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n};\r\n\r\nexport const deleteData = async (storeName, id) => {\r\n  const store = await getObjectStore(storeName, 'readwrite');\r\n  return new Promise((resolve, reject) => {\r\n    const request = store.delete(id);\r\n    request.onsuccess = () => resolve(request.result);\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n};\r\n\r\nexport const clearStore = async (storeName) => {\r\n  const store = await getObjectStore(storeName, 'readwrite');\r\n  return new Promise((resolve, reject) => {\r\n    const request = store.clear();\r\n    request.onsuccess = () => resolve(request.result);\r\n    request.onerror = () => reject(request.error);\r\n  });\r\n};\r\n\r\nexport const initializeDBFromLocalStorage = async () => {\r\n  const db = await openDB();\r\n  const transaction = db.transaction(STORES, 'readwrite');\r\n\r\n  for (const storeName of STORES) {\r\n    const store = transaction.objectStore(storeName);\r\n    const countRequest = store.count();\r\n\r\n    await new Promise((resolve, reject) => {\r\n      countRequest.onsuccess = () => {\r\n        if (countRequest.result === 0) {\r\n          const localStorageData = JSON.parse(localStorage.getItem(storeName)) || [];\r\n          localStorageData.forEach(item => {\r\n            store.add(item);\r\n          });\r\n          console.log(`IndexedDB store '${storeName}' initialized from localStorage.`);\r\n        }\r\n        resolve();\r\n      };\r\n      countRequest.onerror = () => reject(countRequest.error);\r\n    });\r\n  }\r\n  console.log('IndexedDB initialization complete.');\r\n};\r\n\r\nexport const syncLocalStorageWithIndexedDB = async (storeName, data) => {\r\n  try {\r\n    localStorage.setItem(storeName, JSON.stringify(data)); \r\n    console.log(`LocalStorage for '${storeName}' synchronized.`);\r\n  } catch (error) {\r\n    console.error(`Error syncing ${storeName}:`, error);\r\n  }\r\n};\r\n\r\nexport const syncWithBackend = async () => {\r\n  console.log('Sincronizando con backend...');\r\n  for (const storeName of STORES) {\r\n    const localData = await getAllData(storeName);\r\n    if (localData.length > 0) {\r\n      console.log(`Enviando ${storeName} a backend:`, localData);\r\n      // Aquí iría la lógica real para enviar datos al backend\r\n    }\r\n  }\r\n  console.log('Sincronización con backend completada.');\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}